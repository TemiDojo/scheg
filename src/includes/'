




int64_t untagInt(int64_t integer) {
    return (integer >> 2) | INT_TAG;
}

void display_parsed_list(Expr *parsed) {
    if (parsed == NULL) {
        printf("NULL");
        return;
    }

    switch (parsed->type) {
        case EXPR_INT:
            printf("%lld", (long long)parsed->as.int_val);
            break;

        case EXPR_CHAR:
            // Print character in Scheme format
            if (parsed->as.char_val == '\n') {
                printf("#\\newline");
            } else if (parsed->as.char_val == ' ') {
                printf("#\\space");
            } else {
                printf("#\\%c", (char)parsed->as.char_val);
            }
            break;

        case EXPR_BOOL:
            if (parsed->as.bool_val == 0) {
                printf("#t");
            } else {
                printf("#f");
            }
            break;

        case EXPR_SYMBOL:
            printf("%s", parsed->as.symbol);
            break;

        case EXPR_LIST:
            printf("(");
            for (size_t i = 0; i < parsed->as.list.count; i++) {
                if (i > 0) {
                    printf(" ");  // Space between elements
                }
                // RECURSIVE CALL for each list item
                display_parsed_list(parsed->as.list.items[i]);
            }
            printf(")");
            break;

        default:
            printf("UNKNOWN");
            break;
    }
}

bool is_symbol_start(char c) {
    // First character of symbol (cannot start with digit)
    return isalpha(c) ||
           c == '+' || c == '-' || c == '*' ||
           c == '<' || c == '>' || c == '=';
}

bool is_symbol_char(char c) {
    // Any character within a symbol (digits allowed)
    return is_symbol_start(c) || isdigit(c);
}



int64_t tagInt(int64_t integer) {
    return (integer << 2) | INT_TAG;
}

int64_t tagChar(int64_t chars){
    return (chars << 8) | CHAR_TAG;
}

int64_t tagBool(int64_t bools) {
    return (bools << 7) | BOOL_TAG;
}

char peek(Parser *p) {
    if(p->pos >= p->length) {
        return '\0';
    }
    return p->source[p->pos];
}

char advance(Parser *p) {
    return p->source[p->pos++];
}

char advanceN(Parser *p) {
    int dummy = p->pos;
    dummy++;
    return p->source[dummy];
}

void skip_whitespace(Parser *p) {
    while(p->pos < p->length) {
        char c = peek(p);
        if (c == ' ') {
            advance(p);
        } else {
            break;
        }
    }
}

Int64_Array initializeInt64_arr() {
    Int64_Array code_array;
    code_array.size = 0;
    code_array.capacity = 1;
    code_array.code = calloc(code_array.capacity, sizeof(int64_t));
    return code_array;
}

void add_element(Int64_Array *code_array, int64_t code) {

    if (code_array->size >= code_array->capacity) {
        code_array->capacity = code_array->capacity * 2;

        code_array->code = realloc(code_array->code, code_array->capacity * sizeof(int64_t
));

        if (code_array->code == NULL) {
            printf("Error: allocation failure\n");
            exit(1);
        }
    }
    code_array->code[code_array->size++] = code;

}
